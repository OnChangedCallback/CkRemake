print("load started")

-- Глобальная таблица переменных
vars = {
    -- Services
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    Workspace = game:GetService("Workspace"),
    HttpService = game:GetService("HttpService"),
    TeleportService = game:GetService("TeleportService"),
    MarketplaceService = game:GetService("MarketplaceService"),
    
    -- Player
    LocalPlayer = game:GetService("Players").LocalPlayer,
    CoreGui = game:GetService("CoreGui"),
    
    -- Math & Constructors
    Vector2new = Vector2.new,
    Vector3new = Vector3.new,
    CFramenew = CFrame.new,
    CFrameAngles = CFrame.Angles,
    Color3new = Color3.new,
    Color3fromRGB = Color3.fromRGB,
    Color3fromHSV = Color3.fromHSV,
    Color3fromHex = Color3.fromHex,
    UDim2new = UDim2.new,
    UDimnew = UDim.new,
    ColorSeqnew = ColorSequence.new,
    ColorSeqKey = ColorSequenceKeypoint.new,
    Instancenew = Instance.new,
    CFramelookAt = CFrame.lookAt,
    mathrad = math.rad,
    mathdeg = math.deg,
    mathsin = math.sin,
    mathcos = math.cos,
    mathatan2 = math.atan2,
    mathsqr = math.sqrt,
    mathabs = math.abs,
    mathmin = math.min,
    mathmax = math.max,
    mathfloor = math.floor,
    mathceil = math.ceil,
    mathpi = math.pi,
    mathatan = math.atan,
    
    -- Drawing
    Drawingnew = Drawing and Drawing.new,
    
    -- Math functions
    math_random = math.random,
    math_min = math.min,
    math_max = math.max,
    math_floor = math.floor,
    math_sin = math.sin,
    math_cos = math.cos,
    math_pi = math.pi,
    
    -- String functions
    str_find = string.find,
    str_sub = string.sub,
    str_format = string.format,
    str_lower = string.lower,
    str_upper = string.upper,
    str_match = string.match,
    
    -- Table functions
    tbl_insert = table.insert,
    tbl_remove = table.remove,
    tbl_find = table.find or function(t, v) for i, val in ipairs(t) do if val == v then return i end end return nil end,
    tbl_concat = table.concat,
    
    -- Task functions
    task_wait = task.wait,
    task_spawn = task.spawn,
    task_defer = task.defer,
    
    -- Other
    tick = tick,
    os_date = os.date,
    pairs = pairs,
    ipairs = ipairs,
    next = next,
    pcall = pcall,
    xpcall = xpcall,
    typeof = typeof or type,
    type = type,
    tostring = tostring,
    tonumber = tonumber,
    rawget = rawget,
    rawset = rawset,
    setmetatable = setmetatable,
    getmetatable = getmetatable,
    
    -- MagicBullets переменные
    LP = game:GetService("Players").LocalPlayer,
    RSStorage = game:GetService("ReplicatedStorage"),
    os_clock = os.clock,
    math_huge = math.huge,
    
}

-- Загрузка UI библиотеки
local library, _, _, _, _, themes, flags = loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/Remakev1/refs/heads/main/lib"))()
print("uiloaded")

-- Утилити библиотека (должна быть до всего остального кода)
local utility = {}
local framework = {connections = {}}

-- Глобальные переменные для RageBot
local ragebot_cycle_index = 1

-- Target Framework удален

-- Глобальные переменные
local config_holder = nil
local default_config = nil
local watermark = nil
local radar = nil

-- Utility функции
do
    -- Получение имени игры с кешированием
    utility.game_name_cache = nil
    utility.get_game_name = function()
        if utility.game_name_cache ~= nil then
            return utility.game_name_cache
        end
        local success, info = pcall(function()
            return vars.MarketplaceService:GetProductInfo(game.PlaceId)
        end)
        local name = success and info and info.Name or tostring(game.PlaceId)
        utility.game_name_cache = name
        return name
    end
    
    -- Создание уведомления
    utility.notify = function(text, duration)
        library:notification({text = text, time = duration or 3})
    end
    
    -- Безопасное получение конфига
    utility.get_config_path = function(name)
        if not name or name == "" then return nil end
        return "StarRemake/configs/" .. name .. ".cfg"
    end
    
    -- Создание colorpicker для UI элементов
    utility.add_colorpicker = function(element, name, default_color, flag, callback)
        return element:colorpicker({
            name = name,
            color = default_color,
            flag = flag,
            callback = callback
        })
    end
    
    -- Проверка существования конфига
    utility.config_exists = function(name)
        if not name or name == "" then return false end
        local path = utility.get_config_path(name)
        return isfile and isfile(path) or false
    end
    
    -- Сохранение конфига
    utility.save_config = function(name)
        if not name or name == "" then
            utility.notify("Enter config name first!", 3)
            return false
        end
        writefile(utility.get_config_path(name), library:get_config())
        library:config_list_update()
        utility.notify("Saved config: " .. name, 3)
        return true
    end
    
    -- Загрузка конфига
    utility.load_config = function(name)
        if not name or name == "" then
            utility.notify("Select a config first!", 3)
            return false
        end
        if not utility.config_exists(name) then
            utility.notify("Config does not exist: " .. name, 3)
            return false
        end
        library:load_config(readfile(utility.get_config_path(name)))
        utility.notify("Loaded config: " .. name, 3)
        return true
    end
    
    -- Удаление конфига
    utility.delete_config = function(name)
        if not name or name == "" then
            utility.notify("Select a config first!", 3)
            return false
        end
        if not utility.config_exists(name) then
            utility.notify("Config does not exist: " .. name, 3)
            return false
        end
        delfile(utility.get_config_path(name))
        library:config_list_update()
        utility.notify("Deleted config: " .. name, 3)
        return true
    end
    
    -- Копирование в буфер обмена
    utility.copy_to_clipboard = function(text)
        if setclipboard then
            setclipboard(text)
            return true
        end
        return false
    end
    
    -- Target Framework Utility функции
    utility.ValidateClient = function(player)
        if not player or not player.Character then
            return false
        end
        local character = player.Character
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            return false
        end
        return humanoid.RootPart ~= nil
    end
    
    utility.GetPreferredPart = function(character)
        return character and 
            (character:FindFirstChild("HumanoidRootPart") or 
             character:FindFirstChild("Head") or 
             character:FindFirstChild("UpperTorso") or
             character:FindFirstChild("Torso")) or nil
    end
    
    utility.ToScreen = function(position)
        local Camera = vars.Workspace.CurrentCamera
        local v, onScreen = Camera:WorldToViewportPoint(position)
        -- Используем WorldToViewportPoint напрямую как в оригинальном коде
        return vars.Vector2new(v.X, v.Y), onScreen
    end
    
    utility.GetMouseLocation = function()
        -- Возвращает абсолютные экранные координаты курсора (совместимы с Drawing)
        local ml = vars.UserInputService:GetMouseLocation()
        return vars.Vector2new(ml.X, ml.Y)
    end
    
    utility.GetMouseDistance = function(screenPoint)
        return (utility.GetMouseLocation() - screenPoint).Magnitude
    end
    
    -- Функции для клонирования целей
    utility.create_target_clone = function(target_player)
        if not target_player or not target_player.Character then return nil end
        
        local character = target_player.Character
        local clone_model = vars.Instance("Model")
        clone_model.Name = "TargetClone_" .. target_player.Name
        
        local part_map = {}
        local clone_hrp = nil
        
        -- Клонирование частей тела
        for _, child in pairs(character:GetDescendants()) do
            if child:IsA("BasePart") and not child.Parent:IsA("Accessory") then
                local clone_part = child:Clone()
                
                -- Удаляем соединения
                for _, descendant in pairs(clone_part:GetDescendants()) do
                    if descendant:IsA("Motor6D") or descendant:IsA("Weld") then
                        descendant:Destroy()
                    end
                end
                
                -- Настройка клонированной части
                clone_part.CanCollide = false
                clone_part.Anchored = true
                clone_part.Transparency = 0.5
                clone_part.Material = Enum.Material.ForceField
                clone_part.BrickColor = vars.BrickColorNew("Bright red")
                clone_part.Parent = clone_model
                
                if clone_part.Name == "HumanoidRootPart" then
                    clone_hrp = clone_part
                end
                
                part_map[clone_part] = child
            end
        end
        
        -- Настройка модели
        if clone_hrp then
            clone_model.PrimaryPart = clone_hrp
        end
        clone_model.Parent = vars.workspace
        
        return {
            model = clone_model,
            part_map = part_map,
            target_player = target_player
        }
    end
    
    utility.update_target_clone = function(clone_data)
        if not clone_data or not clone_data.model or not clone_data.part_map then return end
        if not clone_data.target_player or not clone_data.target_player.Character then return end
        
        local prediction_value = framework.ragebot.prediction_value or 0.15
        
        for clone_part, original_part in pairs(clone_data.part_map) do
            if original_part and original_part.Parent then
                -- Применяем предикцию к позиции клона
                local predicted_pos = original_part.Position + vars.Vector3new(
                    original_part.Velocity.X * prediction_value,
                    original_part.Velocity.Y * prediction_value,
                    original_part.Velocity.Z * prediction_value
                )
                clone_part.CFrame = vars.CFramenew(predicted_pos) * (original_part.CFrame - original_part.Position)
            end
        end
    end
    
    utility.destroy_target_clone = function(clone_data)
        if clone_data and clone_data.model then
            clone_data.model:Destroy()
        end
    end

    -- RageBot Targeting функции
    utility.get_all_players = function()
        local targets = {}
        
        -- Добавляем игроков
        for _, player in pairs(vars.Players:GetPlayers()) do
            if player ~= vars.LocalPlayer and utility.ValidateClient(player) then
                vars.tbl_insert(targets, player)
            end
        end
        
        -- Добавляем dummy объекты
        for _, obj in pairs(vars.Workspace:GetChildren()) do
            if obj.Name == "Dummy" and obj:FindFirstChild("Humanoid") and obj:FindFirstChild("HumanoidRootPart") then
                local humanoid = obj:FindFirstChild("Humanoid")
                if humanoid.Health > 0 then
                    -- Создаем псевдо-игрока для dummy
                    local dummy_player = {
                        Name = "Dummy",
                        Character = obj,
                        IsDummy = true
                    }
                    vars.tbl_insert(targets, dummy_player)
                end
            end
        end
        
        return targets
    end
    
    utility.get_closest_to_cursor = function()
        local mouse_pos = utility.GetMouseLocation()
        local closest_player = nil
        local closest_distance = vars.math_huge
        
        for _, player in pairs(utility.get_all_players()) do
            local character = player.Character
            if character then
                local part = utility.GetPreferredPart(character)
                if part then
                    local screen_pos, on_screen = utility.ToScreen(part.Position)
                    -- Не требуем чтобы цель была на экране для RageBot
                    local distance = utility.GetMouseDistance(screen_pos)
                    if distance < closest_distance then
                        closest_distance = distance
                        closest_player = player
                    end
                end
            end
        end
        
        return closest_player
    end
    
    utility.cycle_targets = function()
        local players = utility.get_all_players()
        if #players == 0 then return nil end
        
        -- Увеличиваем индекс для следующей цели
        ragebot_cycle_index = ragebot_cycle_index + 1
        if ragebot_cycle_index > #players then
            ragebot_cycle_index = 1
        end
        
        return players[ragebot_cycle_index]
    end
    
    -- Получение лучшей части тела для прицеливания с приоритетами
    utility.get_best_target_part = function(character)
        if not character then return nil end
        
        local target_parts = framework.ragebot.target_parts or {"Head", "Torso"}
        local part_priority = {
            ["Head"] = 1,
            ["Torso"] = 2, 
            ["LeftArm"] = 3,
            ["RightArm"] = 3,
            ["LeftLeg"] = 4,
            ["RightLeg"] = 4
        }
        
        local best_part = nil
        local best_priority = 999
        
        for _, part_name in pairs(target_parts) do
            local part = character:FindFirstChild(part_name)
            if part and part_priority[part_name] < best_priority then
                best_part = part
                best_priority = part_priority[part_name]
            end
        end
        
        return best_part
    end
    
    -- Функция предикции позиции цели (только Velocity метод)
    utility.predict_target_position = function(target_player, target_part)
        if not target_player or not target_player.Character or not target_part then
            return target_part and target_part.Position or vars.Vector3new(0, 0, 0)
        end
        
        local prediction = framework.ragebot.prediction_value or 0.15
        
        return target_part.Position + vars.Vector3new(
            target_part.Velocity.X * prediction,
            target_part.Velocity.Y * prediction,
            target_part.Velocity.Z * prediction
        )
    end
    
    -- Получение позиции с multipoints и предикцией
    utility.get_multipoint_position = function(part, part_name, target_player)
        if not part then return nil end
        
        local multipoint_value = 0.01
        if part_name == "Head" then
            multipoint_value = framework.ragebot.multipoints.head
        elseif part_name == "Torso" then
            multipoint_value = framework.ragebot.multipoints.torso
        elseif part_name == "LeftArm" or part_name == "RightArm" then
            multipoint_value = framework.ragebot.multipoints.arms
        elseif part_name == "LeftLeg" or part_name == "RightLeg" then
            multipoint_value = framework.ragebot.multipoints.legs
        end
        
        -- Используем предиктированную позицию если включена интерполяция
        local center_pos = part.Position
        if framework.ragebot.interpolation and target_player then
            center_pos = utility.predict_target_position(target_player, part)
        end
        
        local size = part.Size
        
        -- Создаем 7 точек: центр + 6 краевых точек
        local points = {
            center_pos, -- Приоритет всегда центру
            center_pos + vars.Vector3new(size.X * multipoint_value, 0, 0),
            center_pos - vars.Vector3new(size.X * multipoint_value, 0, 0),
            center_pos + vars.Vector3new(0, size.Y * multipoint_value, 0),
            center_pos - vars.Vector3new(0, size.Y * multipoint_value, 0),
            center_pos + vars.Vector3new(0, 0, size.Z * multipoint_value),
            center_pos - vars.Vector3new(0, 0, size.Z * multipoint_value)
        }
        
        return points[1] -- Возвращаем центр как приоритетную точку
    end
    
    utility.get_target_position = function(player)
        if not player or not player.Character then return nil end
        local part = utility.get_best_target_part(player.Character)
        if not part then return nil end
        return utility.get_multipoint_position(part, part.Name, player)
    end
    
    -- Функция для обновления текста watermark
    utility.update_watermark_text = function()
        local watermark_type = flags["watermark_type"]
        local parts = {}
        
        if type(watermark_type) == "table" then
            local selected = {}
            for _, option in next, watermark_type do
                selected[option] = true
            end
            
            if selected["Date"] then
                parts[#parts + 1] = os.date("%y:%m:%d")
            end
            if selected["Time"] then
                parts[#parts + 1] = os.date("%H:%M:%S")
            end
            if selected["Place"] then
                parts[#parts + 1] = utility.get_game_name()
            end
            if selected["User"] then
                parts[#parts + 1] = vars.LocalPlayer and vars.LocalPlayer.Name or "?"
            end
        end
        
        if #parts == 0 then
            parts[1] = os.date("%H:%M:%S")
        end
        
        return "luasex - " .. table.concat(parts, " - ")
    end
    
    -- Безопасное выполнение HTTP запроса с повторными попытками
    utility.http_get_with_retry = function(url, attempts)
        attempts = attempts or 5
        local delay = 1
        for i = 1, attempts do
            local ok, body = pcall(function()
                return game:HttpGetAsync(url)
            end)
            if ok then
                return true, body
            else
                local msg = tostring(body)
                if vars.str_find(msg, "429") or vars.str_find(msg, "Too Many Requests") then
                    vars.task_wait(delay + (vars.math_random(0, 250) / 1000))
                    delay = vars.math_min(delay * 2, 8)
                else
                    return false, msg
                end
            end
        end
        return false, "Max attempts reached"
    end
    
    -- Получение списка серверов
    utility.fetch_servers = function()
        local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
        local ok, body = utility.http_get_with_retry(url)
        if not ok then
            utility.notify("Failed to fetch servers: " .. tostring(body), 3)
            return nil
        end
        
        local ok2, decoded = pcall(function()
            return vars.HttpService:JSONDecode(body)
        end)
        if not ok2 then
            utility.notify("Failed to decode server list", 3)
            return nil
        end
        
        return decoded
    end
    
    -- Телепорт на новый сервер
    utility.join_new_server = function(max_players)
        local servers = utility.fetch_servers()
        if not servers or not servers.data or #servers.data == 0 then
            utility.notify("Сервера недоступны или пустой список", 3)
            return
        end
        
        local candidates = {}
        for _, s in ipairs(servers.data) do
            if s.id ~= game.JobId and s.playing < s.maxPlayers and s.playing <= (max_players or 15) then
                vars.tbl_insert(candidates, s)
            end
        end
        
        if #candidates == 0 then
            utility.notify("Свободных серверов не найдено", 3)
            return
        end
        
        local target = candidates[vars.math_random(1, #candidates)]
        vars.TeleportService:TeleportToPlaceInstance(game.PlaceId, target.id, vars.LocalPlayer)
    end
    
    -- MagicBullets функция стрельбы
    utility.ShootAtPlayer = function(player)
        if not player or not player.Character or not flags["MagicBullets"] then return end
        
        -- Проверка патронов
        local WeaponTool = vars.LP.Character and vars.LP.Character:FindFirstChildWhichIsA("Tool")
        if WeaponTool then
            local Ammo = WeaponTool:FindFirstChild("Ammo")
            if Ammo and Ammo.Value <= 0 then return end
        end
        
        -- Не стреляем по мёртвым, но разрешаем стрелять по Grabbed
        if player.Character:FindFirstChildOfClass("Humanoid") and player.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            return 
        end
        
        -- Ждём пока ForceField исчезнет, чтобы bullets прошли
        if player.Character:FindFirstChildOfClass("ForceField") then return end
        
        local Head = player.Character:FindFirstChild("Head")
        if not Head then return end
        
        local TempChar = vars.LP.Character
        if not TempChar then return end
        
        local Weapon = nil
        for _, tool in ipairs(TempChar:GetChildren()) do
            if tool:IsA("Tool") then
                Weapon = tool
                break
            end
        end
        
        if not Weapon then return end
        
        local Handle = Weapon:FindFirstChild("Handle")
        if not Handle then return end
        
        local HeadPos = Head.Position
        local Args = {
            "ShootGun",
            Handle,
            HeadPos,
            {HeadPos, HeadPos, HeadPos, HeadPos, HeadPos},
            {Head, Head, Head, Head, Head},
            {vars.Vector3new(0,1,0), vars.Vector3new(0,1,0), vars.Vector3new(0,1,0), vars.Vector3new(0,1,0), vars.Vector3new(0,1,0)},
            {},
            vars.os_clock(),
            vars.math_huge,
            {HeadPos, HeadPos, HeadPos, HeadPos, HeadPos},
            5,
            0.2,
            HeadPos
        }
        
        local ShootEvent = vars.RSStorage:FindFirstChild("ShootEvent")
        if ShootEvent then
            ShootEvent:FireServer(unpack(Args))
        end
    end
end

    -- RageBot Framework
do
    framework.ragebot = {
        enabled = false,
        target = nil,
        target_method = "NearestToCursor",
        cycle_speed = 0.5,
        last_cycle_time = 0,
        target_parts = {"Head", "Torso"},
        multipoints = {
            head = 0.01,
            torso = 0.01,
            arms = 0.01,
            legs = 0.01
        },
        interpolation = false,
        prediction_value = 0.15,
        show_aimbot = false,
        tracer_part = nil,
        target_clones = {} -- Хранилище клонов целей
    }
    
    -- Управление клонами целей
    framework.manage_target_clone = function(target_player)
        if not framework.ragebot.interpolation or not target_player then
            -- Если интерполяция выключена, удаляем клон
            local clone_key = target_player and target_player.Name or "unknown"
            if framework.ragebot.target_clones[clone_key] then
                utility.destroy_target_clone(framework.ragebot.target_clones[clone_key])
                framework.ragebot.target_clones[clone_key] = nil
            end
            return
        end
        
        local clone_key = target_player.Name
        
        -- Если клон уже существует, обновляем его
        if framework.ragebot.target_clones[clone_key] then
            utility.update_target_clone(framework.ragebot.target_clones[clone_key])
        else
            -- Создаем новый клон
            local clone_data = utility.create_target_clone(target_player)
            if clone_data then
                framework.ragebot.target_clones[clone_key] = clone_data
            end
        end
    end
    
    -- Очистка всех клонов
    framework.clear_all_clones = function()
        for clone_key, clone_data in pairs(framework.ragebot.target_clones) do
            utility.destroy_target_clone(clone_data)
        end
        framework.ragebot.target_clones = {}
    end
    
    -- Получение цели по выбранному методу
    framework.get_ragebot_target = function()
        if not framework.ragebot.enabled then return nil end
        
        if framework.ragebot.target_method == "NearestToCursor" then
            return utility.get_closest_to_cursor()
        elseif framework.ragebot.target_method == "Cycle" then
            local current_time = vars.tick()
            if current_time - framework.ragebot.last_cycle_time >= framework.ragebot.cycle_speed then
                framework.ragebot.last_cycle_time = current_time
                return utility.cycle_targets()
            else
                -- Возвращаем текущую цель если время цикла не прошло
                local players = utility.get_all_players()
                if #players > 0 and ragebot_cycle_index <= #players then
                    return players[ragebot_cycle_index]
                end
            end
        end
        
        return nil
    end
    
    -- Функции для 3D трейсера
    framework.create_aimbot_tracer = function(start_pos, end_pos)
        if not framework.ragebot.show_aimbot then return end
        
        -- Удаляем старый трейсер
        framework.cleanup_aimbot_tracer()
        
        -- Создаем новый Part для трейсера
        local tracer_part = vars.Instancenew("Part")
        tracer_part.Name = "AimbotTracer"
        tracer_part.Anchored = true
        tracer_part.CanCollide = false
        tracer_part.Material = Enum.Material.Neon
        tracer_part.BrickColor = BrickColor.new("Bright red")
        tracer_part.Transparency = 0.5
        
        -- Вычисляем размер и позицию
        local distance = (end_pos - start_pos).Magnitude
        tracer_part.Size = vars.Vector3new(0.1, 0.1, distance)
        tracer_part.CFrame = vars.CFramenew(start_pos:Lerp(end_pos, 0.5), end_pos)
        
        tracer_part.Parent = vars.Workspace
        framework.ragebot.tracer_part = tracer_part
        
        -- Автоудаление через 0.1 секунды
        vars.task_spawn(function()
            vars.task_wait(0.1)
            if tracer_part and tracer_part.Parent then
                tracer_part:Destroy()
            end
        end)
    end
    
    framework.cleanup_aimbot_tracer = function()
        if framework.ragebot.tracer_part then
            framework.ragebot.tracer_part:Destroy()
            framework.ragebot.tracer_part = nil
        end
    end
    
    -- Установка позиции цели для rageaim и активация autoshoot
    framework.set_rageaim_target = function(target_player)
        local character = vars.LocalPlayer.Character
        if not character then return end
        
        if not target_player then
            -- Отключаем rageaim и autoshoot если нет цели
            local rageaim_value = character:FindFirstChild("rageaim")
            if rageaim_value then
                rageaim_value.Value = false
            end
            
            local autoshoot_value = character:FindFirstChild("autoshoot")
            if autoshoot_value then
                autoshoot_value.Value = false
            end
            
            framework.cleanup_aimbot_tracer()
            return
        end
        
        local target_pos = utility.get_target_position(target_player)
        if not target_pos then return end
        
        -- Создаем или обновляем BoolValue для rageaim
        local rageaim_value = character:FindFirstChild("rageaim")
        if not rageaim_value then
            rageaim_value = vars.Instancenew("BoolValue")
            rageaim_value.Name = "rageaim"
            rageaim_value.Parent = character
        end
        rageaim_value.Value = true
        
        -- Создаем или обновляем Vector3Value для позиции цели
        local aimpos_value = character:FindFirstChild("aimpos")
        if not aimpos_value then
            aimpos_value = vars.Instancenew("Vector3Value")
            aimpos_value.Name = "aimpos"
            aimpos_value.Parent = character
        end
        aimpos_value.Value = target_pos
        
        -- RageBot всегда включает autoshoot
        local autoshoot_value = character:FindFirstChild("autoshoot")
        if not autoshoot_value then
            autoshoot_value = vars.Instancenew("BoolValue")
            autoshoot_value.Name = "autoshoot"
            autoshoot_value.Parent = character
        end
        autoshoot_value.Value = true
        
        -- Создаем 3D трейсер если включен ShowAimbot
        if framework.ragebot.show_aimbot then
            local weapon = character:FindFirstChildWhichIsA("Tool")
            if weapon then
                local bullet_start = weapon:FindFirstChild("BulletStart")
                if bullet_start then
                    framework.create_aimbot_tracer(bullet_start.Position, target_pos)
                end
            end
        end
    end
    
    -- Основной цикл RageBot
    framework.ragebot_loop = function()
        if not framework.ragebot.enabled then return end
        
        local target = framework.get_ragebot_target()
        framework.ragebot.target = target
        framework.set_rageaim_target(target)
    end
end

do
    -- Создание окна
    local window = library:window({
        name = "luasex",
        size = vars.UDim2new(0, 780, 0, 639)
    })
    
    _G.RagebotTab = window:tab({ name = "RageBot", enabled = true })
    _G.AntiAimTab = window:tab({ name = "AntiAim", enabled = true })
    _G.VisualsTab = window:tab({ name = "Visuals", enabled = true })
    _G.ConfigTab = window:tab({ name = "Config", enabled = true })
    _G.window = window
    
    
    -- Создание HUD элементов
    watermark = library:watermark({
        text = "luasex - " .. vars.os_date("%H:%M:%S")
    })
    
    radar = library:radar({
        enabled = false,
        size = 200
    })
end

-- RageBot Tab содержимое
do
    local RagebotTab = _G.RagebotTab
    
    -- Первая колонка
    local ragebot_column1 = RagebotTab:column()
    local targeting_section = ragebot_column1:section({name = "Targeting"})
    
    -- Тогл RageBot
    targeting_section:toggle({
        name = "RageBot",
        flag = "ragebot_enabled",
        callback = function(value)
            framework.ragebot.enabled = value
            if not value then
                -- Отключаем rageaim при выключении RageBot
                framework.set_rageaim_target(nil)
            end
        end
    })
    
    -- Дропдаун для метода таргетинга
    local target_method_dropdown = targeting_section:dropdown({
        name = "Target Method",
        flag = "ragebot_target_method",
        items = {"NearestToCursor", "Cycle"},
        callback = function(value)
            framework.ragebot.target_method = value
            -- Сбрасываем индекс цикла при смене метода
            if value == "Cycle" then
                ragebot_cycle_index = 1
                framework.ragebot.last_cycle_time = 0
            end
        end
    })
    
    -- Dependency box для Cycle настроек
    local cycle_dependency = targeting_section:dependency_box()
    cycle_dependency:setup_dependencies({
        { target_method_dropdown, "Cycle" }
    })
    
    -- Слайдер для скорости цикла внутри dependency box
    cycle_dependency:slider({
        name = "Cycle Speed",
        flag = "ragebot_cycle_speed",
        min = 0.05,
        max = 1.0,
        interval = 0.05,
        suffix = "s",
        callback = function(value)
            framework.ragebot.cycle_speed = value
        end
    })
    
    -- Вторая колонка
    local ragebot_column2 = RagebotTab:column()
    local aimbot_section = ragebot_column2:section({name = "Aimbot"})
    
    -- Мульти-дропдаун для частей тела с приоритетами
    aimbot_section:dropdown({
        name = "Target Parts",
        flag = "ragebot_target_parts",
        items = {"Head", "Torso", "LeftArm", "RightArm", "LeftLeg", "RightLeg"},
        multi = true,
        callback = function(selected)
            framework.ragebot.target_parts = selected
        end
    })
    
    -- Слайдеры multipoints для каждой части тела
    aimbot_section:slider({
        name = "Head Multipoints",
        flag = "multipoints_head",
        min = 1,
        max = 100,
        interval = 1,
        suffix = "%",
        callback = function(value)
            framework.ragebot.multipoints.head = value / 100
        end
    })
    
    aimbot_section:slider({
        name = "Torso Multipoints", 
        flag = "multipoints_torso",
        min = 1,
        max = 100,
        interval = 1,
        suffix = "%",
        callback = function(value)
            framework.ragebot.multipoints.torso = value / 100
        end
    })
    
    aimbot_section:slider({
        name = "Arms Multipoints",
        flag = "multipoints_arms", 
        min = 1,
        max = 100,
        interval = 1,
        suffix = "%",
        callback = function(value)
            framework.ragebot.multipoints.arms = value / 100
        end
    })
    
    aimbot_section:slider({
        name = "Legs Multipoints",
        flag = "multipoints_legs",
        min = 1,
        max = 100,
        interval = 1,
        suffix = "%",
        callback = function(value)
            framework.ragebot.multipoints.legs = value / 100
        end
    })
    
    -- Тогл Interpolation для предикции движения (только Velocity метод)
    aimbot_section:toggle({
        name = "Interpolation",
        flag = "ragebot_interpolation",
        callback = function(value)
            framework.ragebot.interpolation = value
        end
    })
    
    -- Dependency box для настроек Interpolation
    local interpolation_dependency = aimbot_section:dependency_box()
    local interpolation_toggle = aimbot_section.elements and aimbot_section.elements[#aimbot_section.elements]
    if interpolation_toggle then
        interpolation_dependency:setup_dependencies({
            { interpolation_toggle, true }
        })
    end
    
    -- Слайдер для значения предикции
    interpolation_dependency:slider({
        name = "Prediction Value",
        flag = "ragebot_prediction_value",
        min = 0.01,
        max = 0.5,
        interval = 0.01,
        suffix = "s",
        callback = function(value)
            framework.ragebot.prediction_value = value
        end
    })
    
    -- Тогл ShowAimbot для 3D трейсера
    aimbot_section:toggle({
        name = "Show Aimbot",
        flag = "ragebot_show_aimbot",
        callback = function(value)
            framework.ragebot.show_aimbot = value
            if not value then
                -- Удаляем существующий трейсер
                framework.cleanup_aimbot_tracer()
            end
        end
    })
end

-- Config Tab содержимое
do
    local ConfigTab = _G.ConfigTab
    local config_column = ConfigTab:column()
    local config_section = config_column:section({name = "Options"})
    
    -- Сохраняем дефолтный конфиг
    default_config = library:get_config()
    
    -- Список конфигов
    config_holder = config_section:list({flag = "config_name_list"})
    
    -- Текстбокс для имени конфига
    config_section:textbox({
        flag = "config_name_text_box",
        placeholder = "Config name"
    })
    
    -- Кнопки управления конфигами
    config_section:button_holder({})
    
    config_section:button({
        name = "Create",
        callback = function()
            local config_name = flags["config_name_text_box"]
            utility.save_config(config_name)
        end
    })
    
    config_section:button({
        name = "Delete",
        callback = function()
            local selected_config = flags["config_name_list"]
            utility.delete_config(selected_config)
        end
    })
    
    config_section:button_holder({})
    
    config_section:button({
        name = "Load",
        callback = function()
            local selected_config = flags["config_name_list"]
            utility.load_config(selected_config)
        end
    })
    
    config_section:button({
        name = "Save",
        callback = function()
            local selected_config = flags["config_name_list"]
            utility.save_config(selected_config)
        end
    })
    
    config_section:button_holder({})
    
    config_section:button({
        name = "Refresh Configs",
        callback = function()
            library:config_list_update()
            utility.notify("Refreshed config list", 2)
        end
    })
    
    config_section:button_holder({})
    
    config_section:button({
        name = "Reset to Default",
        callback = function()
            library:load_config(default_config)
            utility.notify("Reset to default config", 3)
        end
    })
    
    config_section:button({
        name = "Unload Menu",
        callback = function()
            library:load_config(default_config)
            for _, gui in pairs(library.guis) do
                gui:Destroy()
            end
            for _, connection in pairs(library.connections) do
                connection:Disconnect()
            end
        end
    })
    
    -- Мульти-секция для Theme, Game, HUD
    local theme_section, game_section, hud_section = ConfigTab:column():multi_section({
        names = {"Theme", "Game", "HUD"}
    })
    
    -- Theme секция
    theme_section:label({name = "Accent"}):colorpicker({
        name = "Accent",
        color = vars.Color3new(139/255, 92/255, 246/255), -- #8B5CF6
        flag = "theme_accent",
        callback = function(color, transparency)
            library:update_theme("accent", color)
        end
    })
    
    local contrast_label = theme_section:label({name = "Contrast"})
    contrast_label:colorpicker({
        name = "Low",
        color = vars.Color3new(30/255, 30/255, 30/255), -- #1E1E1E
        flag = "theme_low",
        callback = function(color)
            if flags["theme_high"] and flags["theme_low"] then
                library:update_theme("contrast", vars.ColorSeqnew({
                    vars.ColorSeqKey(0, flags["theme_low"].Color),
                    vars.ColorSeqKey(1, flags["theme_high"].Color)
                }))
            end
        end
    })
    contrast_label:colorpicker({
        name = "High",
        color = vars.Color3new(45/255, 45/255, 45/255), -- #2D2D2D
        flag = "theme_high",
        callback = function(color)
            if flags["theme_high"] and flags["theme_low"] then
                library:update_theme("contrast", vars.ColorSeqnew({
                    vars.ColorSeqKey(0, flags["theme_low"].Color),
                    vars.ColorSeqKey(1, flags["theme_high"].Color)
                }))
            end
        end
    })
    
    local inline_label = theme_section:label({name = "Inline"})
    inline_label:colorpicker({
        name = "Inline",
        color = vars.Color3new(60/255, 60/255, 60/255), -- #3C3C3C
        flag = "theme_inline",
        callback = function(color, transparency)
            library:update_theme("inline", color)
        end
    })
    inline_label:colorpicker({
        name = "Outline",
        color = vars.Color3new(0, 0, 0), -- #000000
        flag = "theme_outline",
        callback = function(color, transparency)
            library:update_theme("outline", color)
        end
    })
    
    local text_label = theme_section:label({name = "TextColor"})
    text_label:colorpicker({
        name = "Main",
        color = vars.Color3new(1, 1, 1), -- #FFFFFF
        flag = "theme_text",
        callback = function(color, transparency)
            library:update_theme("text", color)
        end
    })
    text_label:colorpicker({
        name = "Outline",
        color = vars.Color3new(0, 0, 0), -- #000000
        flag = "theme_text_outline",
        callback = function(color, transparency)
            library:update_theme("text_outline", color)
        end
    })
    
    theme_section:label({name = "Glow"}):colorpicker({
        name = "Glow",
        color = vars.Color3new(139/255, 92/255, 246/255), -- #8B5CF6
        flag = "theme_glow",
        callback = function(color, transparency)
            library:update_theme("glow", color)
        end
    })
    
    -- HUD секция
    hud_section:label({name = "UI Bind"}):keybind({
        callback = _G.window.set_menu_visibility,
        key = Enum.KeyCode.Insert,
    })
    
    hud_section:toggle({
        name = "Keybind List",
        flag = "keybind_list",
        callback = function(enabled)
            if library.keybind_list_frame then
                library.keybind_list_frame.Visible = enabled
            end
        end
    })
    
    local watermark_toggle = hud_section:toggle({
        name = "Watermark",
        flag = "watermark",
        callback = function(enabled)
            watermark.set_visible(enabled)
            if enabled then
                watermark.change_text(utility.update_watermark_text())
            end
        end
    })
    
    hud_section:dropdown({
        name = "Watermark Type",
        flag = "watermark_type",
        items = {"Time", "Date", "Place", "User"},
        multi = true,
        default = {"Time"},
        callback = function(selected)
            watermark.change_text(utility.update_watermark_text())
        end
    })
    
    local radar_toggle = hud_section:toggle({
        name = "Radar",
        flag = "hud_radar",
        callback = function(enabled)
            radar.set_visible(enabled)
            if enabled then
                -- Добавляем всех игроков при включении радара
                for _, player in ipairs(vars.Players:GetPlayers()) do
                    if player ~= vars.LocalPlayer and radar and radar.add_dot then
                        pcall(function() radar.add_dot(player) end)
                    end
                end
            end
        end
    })
    
    hud_section:slider({
        name = "Radar Zoom",
        flag = "radar_zoom",
        min = 0.1,
        max = 2,
        default = 1,
        interval = 0.1,
        callback = function(value)
            radar.set_zoom(value)
        end
    })
    
    -- Game секция
    game_section:button_holder({})
    
    game_section:button({
        name = "Copy JobId",
        callback = function()
            utility.copy_to_clipboard(game.JobId)
            utility.notify("Copied JobId to clipboard", 2)
        end
    })
    
    game_section:button({
        name = "Copy GameID",
        callback = function()
            utility.copy_to_clipboard(tostring(game.GameId))
            utility.notify("Copied GameId to clipboard", 2)
        end
    })
    
    game_section:button_holder({})
    
    game_section:button({
        name = "Copy Join Script",
        callback = function()
            local script = vars.str_format(
                'game:GetService("TeleportService"):TeleportToPlaceInstance(%d, "%s", game.Players.LocalPlayer)',
                game.PlaceId, game.JobId
            )
            utility.copy_to_clipboard(script)
            utility.notify("Copied join script to clipboard", 2)
        end
    })
    
    game_section:button_holder({})
    
    game_section:button({
        name = "Rejoin",
        callback = function()
            vars.TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, vars.LocalPlayer)
        end
    })
    
    game_section:button_holder({})
    
    game_section:button({
        name = "Join New Server",
        callback = function()
            utility.join_new_server(flags["max_players"])
        end
    })
    
    game_section:slider({
        name = "Max Players",
        flag = "max_players",
        min = 0,
        max = 40,
        default = 15,
        interval = 1
    })
end

-- Target Framework функции удалены

-- Логика удержания цели удалена

-- Framework: Radar система (перенесено в HUD секцию)
do
    framework.add_player_to_radar = function(player)
        if player ~= vars.LocalPlayer and radar and radar.add_dot then
            pcall(function() radar.add_dot(player) end)
        end
    end
    
    framework.remove_player_from_radar = function(player)
        if radar and radar.remove_dot then
            pcall(function() radar.remove_dot(player) end)
        end
    end
    
    framework.update_radar_positions = function()
        if radar and radar.update_dot then
            for _, player in ipairs(vars.Players:GetPlayers()) do
                if player ~= vars.LocalPlayer then
                    local character = player.Character
                    local root = character and character:FindFirstChild("HumanoidRootPart")
                    if root then
                        pcall(function() radar.update_dot(player, root.Position) end)
                    end
                end
            end
        end
    end
    
    -- Подключаем события
    vars.tbl_insert(library.connections, vars.Players.PlayerAdded:Connect(framework.add_player_to_radar))
    vars.tbl_insert(library.connections, vars.Players.PlayerRemoving:Connect(framework.remove_player_from_radar))
    
    -- Запускаем обновление позиций
    local radar_connection = vars.RunService.RenderStepped:Connect(framework.update_radar_positions)
    vars.tbl_insert(library.connections, radar_connection)
end

-- RageBot основной цикл
do
    local ragebot_connection = vars.RunService.Heartbeat:Connect(function()
        framework.ragebot_loop()
    end)
    vars.tbl_insert(framework.connections, ragebot_connection)
end

-- Обновление watermark каждую секунду
do
    vars.task_spawn(function()
        while vars.task_wait(1) do
            if flags["watermark"] then
                watermark.change_text(utility.update_watermark_text())
            end
        end
    end)
end


-- Инициализация темы
library:update_theme("accent", vars.Color3new(139/255, 92/255, 246/255))
library:update_theme("contrast", vars.ColorSeqnew({
    vars.ColorSeqKey(0, vars.Color3new(30/255, 30/255, 30/255)),
    vars.ColorSeqKey(1, vars.Color3new(45/255, 45/255, 45/255))
}))
library:update_theme("inline", vars.Color3new(60/255, 60/255, 60/255))
library:update_theme("outline", vars.Color3new(0, 0, 0))
library:update_theme("text", vars.Color3new(1, 1, 1))
library:update_theme("text_outline", vars.Color3new(0, 0, 0))
library:update_theme("glow", vars.Color3new(139/255, 92/255, 246/255))

-- Обновляем список конфигов при загрузке
library:config_list_update()

print("load finished")
